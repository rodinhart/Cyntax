# Cyntax

JavaScript is a great and powerful language. However, some of its syntax can be clumsy and verbose, and some of its default behaviour unhelpful.

## Conditionals

Coding for multiple conditionals in JavaScript can become messy. For example:

```js
// prettier-ignore
return a === 1 ? "one"
     : b === 2 && c !== 3 ? "two"
     : d > 4 ? "three"
     : d <= 10 ? "four"
     : "five"
```

When the conditionals get more complicated we'd be better off using a switch statement. However, switch only allows value comparison, not predicates, but we can turn it around:

```js
;(() => {
  switch (true) {
    case a === 1:
      return "one"

    case b === 2 && c !== 3:
      return "two"

    case d > 4:
      return "three"

    case d <= 10:
      return "four"

    default:
      return "five"
  }
})()
```

Notice we had to work around the fact that switch is a statement, not an expression. There is also a small gotcha: the predicates _have_ to return `true`, truthy will not suffice.

There is a lot of syntactical noise with the repetition of `case`, `:` and `return`. With Cyntax:

```clj
(cond
  (= a 1) "one"
  (and (= b 2) (not= c 3)) "two"
  (> d 4) "three"
  (<= d 10) "four"
  true "five")
```

## Threading macro

As an example, take building a histogram of characters in a string using standard library functions:

```js
const histogram = Object.entries(Object.groupBy(text.split(""), identity).map(
  ([key, lst]) => [key, lst.length]
)
```

Because JavaScript is a mix of static functions and object methods, half of the above reads inside-out, the other left-to-right. One way to improve on this is to introduce a function `thread`:

```js
const thread = (x, ...fns) => fns.reduce((r, fn) => fn(r), x)

const histogram = thread(
  text,
  (s) => s.split(""),
  (xs) => Object.groupBy(xs, identity),
  (groups) => Object.entries(groups),
  (entries) => entries.map(([key, lst]) => [key, lst.length])
)
```

This would be improved if all operations were functions with the collection as the last parameter:

```js
const histogram = thread(
  text,
  (s) => split("", s),
  (xs) => groupBy(identity, xs),
  (entries) => map(([key, lst]) => [key, lst.length], entries)
)
```

`Object.entries` has been eliminated by assuming `map` also operates on plain objects. But I still have write a lambda for each step and name the intermediate results. With the abstraction powers of LISP macros, we can write the following Cyntax:

```clj
(def histogram (->> text
  (split "")
  (groupBy identity)
  (map (fn [[key lst]] [key (length lst)]))))
```

Other examples of syntax abstraction using macros are lazy sequences, conditionals, pattern matching and for comprehension. Partial solutions exists in JavaScript, but usually require nullary lambdas to delay evaluation. This is of course half of what a macro does, the other half being altering code before evaluation. This is not possible in JavaScript without the use of eval, at which point you are defining at least a DSL anyway.

# How to use

Cyntax follows JavaScript as closely as possible. This includes data structures, calling conventions and modules. The library that comes with Cyntax makes some different choices however, mostly in term of values, value equality and immutability.

Inclusion of Cyntax is done through modules:

```js
// file: extraMaths.js

import cyntax from "./cyntax.js"
import { square } from "./baseMaths.js"

export default cyntax({ square })`
 
(defn cube [x] (* x (square x)))
 
`
```

`cyntax` takes a scope extension, `square` in this case, and a template literal containing Cyntax. The return an object with any key/values defined in Cyntax. This in turn could be used in another JavaScript or Cyntax module:

```js
import extraMaths from "./extraMaths.js"

console.log(extraMath.cube(3)) // 27
```

Exports from Cyntax have to be in object form for two reasons: Module `import` and `export` are static statements, and can therefor not be generated by Cyntax without a project compilation pipeline. And Cyntax symbols can contain characters not allowed by JavaScript (e.g. `null?`).

# Reference

**+**

**-**

**\***

**/**

**%**

**=**

**<**

**>**

**->**

**->>**

**|**

**and**

**apply**

**array**

**assoc**

**assoc-in**

**car**

**cdr**

**comp**

**cond**

**conj**

**cons**

**constantly**

**contains?**

**count**

**cycle**

**def**

**defn**

**defmacro**

**dissoc**

**drop**

**eval**

**filter**

**filter-array**

**first**

**fold**

**get**

**get-in**

**identity**

**inc**

**into**

**keys**

**lazy-cons**

**list**

**list?**

**log**

**macroexpand**

**map**

**map-array**

**map-list**

**max**

**name**

**nil**

**nil?**

**not**

**not=**

**odd?**

**range**

**rest**

**seq**

**slice**

**string**

**symbol?**

**take**

**tap**

**test**

**update**

**update-in**

**upper-case**

**vals**

# TODO

- use Map instead of { hashmap }
  - Make hashmap proper ADT
- fix defining something already in scope
- multi arity in protocol ?
  - (count nil 2) doesn't throw error
  - protocol Blah (foo []) (foo [x]) ?
- destructering
- and#
- tests
- is export-as-object model suitable for tree shaking?

# Internals

- types are implemented as JavaScript classes, although built-in classes (like String and Array) are shadowed by plain object to avoid polution
- built-in types that have literal syntax cannot be instantiated using constructor
- nil, false, true are values, not symbols
- nil and false are false, everything else if true
- there is only the single quote ', which is a syntax quote
- ~ and ~@ are unquote and unquote-splice
